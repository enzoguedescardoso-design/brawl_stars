<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<title>MOBA Heist MVP — Mobile / Desktop (Velocidade Corrigida) — Bots Desgrudando — Joysticks + Super (Super Left) — Mortis + Colt + Nita</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
  :root{
    --bg-1: #071326;
    --bg-2: #06364a;
    --accent: #2f9cff;
    --accent-2: #ff6b6b;
    --panel: rgba(18,20,23,0.82);
    --glass: rgba(255,255,255,0.04);
    --muted: rgba(255,255,255,0.75);
    --card: rgba(255,255,255,0.03);
    --glass-strong: rgba(255,255,255,0.06);
    --shadow: 0 10px 30px rgba(2,8,23,0.6);
    --radius: 12px;
    --glass-blur: 6px;
  }

  * { box-sizing: border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: linear-gradient(180deg,var(--bg-1), var(--bg-2)); color:var(--muted); -webkit-tap-highlight-color: transparent; }

  #app-wrap { display:flex; height:100vh; align-items:center; justify-content:center; gap:20px; padding:18px; position:relative; }

  canvas {
    display:block;
    width:100%;
    max-width:880px;
    aspect-ratio: 4/3;
    border-radius:14px;
    box-shadow: var(--shadow), 0 2px 8px rgba(0,0,0,0.45);
    border: 1px solid rgba(255,255,255,0.04);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
    image-rendering: optimizeSpeed;
    transform-origin: center;
    touch-action: none; /* evita pan do navegador */
  }

  #topUI{
    position: absolute;
    top:18px;
    left:50%;
    transform: translateX(-50%);
    z-index:30;
    background: linear-gradient(180deg, rgba(0,0,0,0.45), rgba(255,255,255,0.02));
    padding:8px 16px;
    border-radius:999px;
    font-weight:700;
    font-size:14px;
    letter-spacing:0.4px;
    border:1px solid rgba(255,255,255,0.04);
    box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    color: #f7fbff;
  }

  #controls{
    position: absolute;
    top:10px;
    right:12px;
    z-index:30;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .btn {
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.06));
    color: #eaf6ff;
    padding:8px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.06);
    cursor:pointer;
    font-weight:800;
    font-size:13px;
    letter-spacing:0.6px;
    box-shadow: 0 4px 14px rgba(2,8,23,0.45);
    transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    backdrop-filter: blur(var(--glass-blur));
    -webkit-user-select: none; user-select: none;
  }
  .btn:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(2,8,23,0.6); }
  .btn:active { transform: translateY(-1px) scale(0.995); }

  /* overlays (platform choice + class selection) */
  .overlay {
    position: absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(3,6,10,0.66), rgba(3,6,10,0.82));
    z-index:60;
    padding:20px;
  }
  .card-panel {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
    border-radius:16px;
    padding:22px;
    min-width:320px;
    box-shadow: 0 18px 50px rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.04);
    text-align:center;
  }
  .choice-row { display:flex; gap:12px; justify-content:center; margin-top:10px; flex-wrap:wrap; }
  .choice {
    padding:12px 16px;
    border-radius:12px;
    cursor:pointer;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border:1px solid rgba(255,255,255,0.04);
    font-weight:800;
    color:#eaf6ff;
    min-width:120px;
  }
  .choice:active { transform:scale(0.99); }

  .cofre-dot { display:inline-block; width:9px; height:9px; border-radius:50%; margin-right:8px; vertical-align:middle; box-shadow: 0 2px 6px rgba(0,0,0,0.6); }
  .cofre-blue { background: var(--accent); }
  .cofre-red { background: var(--accent-2); }

  /* Joystick (mobile) */
  .joystick {
    position: fixed;
    bottom: 18px;
    width: 140px;
    height: 140px;
    border-radius: 999px;
    z-index: 80;
    display: none; /* aparece apenas no modo mobile via JS */
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    opacity: 0.88;
    transition: opacity .12s ease, transform .12s ease;
  }
  .joy-base {
    position: absolute;
    inset: 0;
    border-radius: 999px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border: 1px solid rgba(255,255,255,0.06);
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 6px 20px rgba(0,0,0,0.45);
  }
  .joy-knob {
    width: 56px;
    height: 56px;
    border-radius: 999px;
    background: rgba(255,255,255,0.12);
    display:block;
    transform: translate(0,0);
    transition: transform .04s linear;
    box-shadow: 0 6px 16px rgba(0,0,0,0.5);
  }
  .left-joy { left: 18px; }
  .right-joy { right: 18px; }

  /* smaller joysticks (used for right and super on mobile) */
  .small-joy { width: 110px; height: 110px; }
  .small-joy .joy-knob { width: 44px; height: 44px; }

  /* super joystick positioned above right joystick - moved slightly left toward center */
  .super-joy { right: 72px; bottom: 110px; }

  @media (max-width:720px){
    #controls { top:8px; right:8px; }
    .card-panel { width:90vw; min-width:unset; }
  }
</style>
</head>
<body>
<div id="app-wrap">
  <canvas id="c" width="1000" height="750"></canvas>
</div>

<div id="topUI"></div>

<div id="controls">
  <button id="restartBtn" class="btn">Restart</button>
  <button id="menuBtn" class="btn">Menu</button>
</div>

<!-- Platform selection overlay (appears first) -->
<div id="platformOverlay" class="overlay" style="display:flex;">
  <div class="card-panel">
    <h2 style="margin:0 0 10px 0; color:#eaf6ff">Você está jogando em:</h2>
    <div class="choice-row">
      <div class="choice" id="chooseDesktop">Computador (Teclado + Mouse)</div>
      <div class="choice" id="chooseMobile">Mobile (Toque)</div>
    </div>
    <div style="margin-top:12px; color:rgba(230,245,255,0.85); font-size:13px">Escolha a plataforma para ajustar os controles.</div>
  </div>
</div>

<!-- Class selection overlay (aparece depois de escolher plataforma) -->
<div id="overlay" class="overlay" style="display:none;">
  <div class="card-panel">
    <h2 style="margin:0 0 8px 0">Brawlers</h2>
    <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
      <div class="choice" onclick="startGame('piper')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Piper</div>
        <small style="display:block; margin-top:4px; font-weight:700">Long range • baixo HP</small>
      </div>
      <div class="choice" onclick="startGame('bull')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Bull</div>
        <small style="display:block; margin-top:4px; font-weight:700">Alta vida • curto alcance</small>
      </div>
      <div class="choice" onclick="startGame('shelly')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Shelly</div>
        <small style="display:block; margin-top:4px; font-weight:700">Ataque em cone • médio</small>
      </div>
      <div class="choice" onclick="startGame('mortis')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Mortis</div>
        <small style="display:block; margin-top:4px; font-weight:700">Dash • causa dano ao colidir</small>
      </div>
      <div class="choice" onclick="startGame('colt')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Colt</div>
        <small style="display:block; margin-top:4px; font-weight:700">5 tiros em linha • dano 20 por bala</small>
      </div>
      <div class="choice" onclick="startGame('nita')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Nita</div>
        <small style="display:block; margin-top:4px; font-weight:700">Médio alcance • tiro largo • Super invoca aliado</small>
      </div>
    </div>
    <div style="text-align:center; margin-top:10px; font-size:13px; opacity:0.95">
      Controles Desktop: <strong>W A S D</strong> para mover • Mouse para mirar • Clique esquerdo para atirar (Mortis: dash) • Clique direito para Super (quando carregado)
      <br/>
      Controles Mobile: use os analógicos (esquerdo = mover, direito = mirar e atirar). Pequeno analógico acima do direito para disparar a Super (quando carregada).
    </div>
  </div>
</div>

<!-- Joysticks — aparecerão apenas em mobile -->
<div id="leftJoy" class="joystick left-joy" aria-hidden="true">
  <div class="joy-base"><div class="joy-knob" id="leftKnob"></div></div>
</div>
<div id="rightJoy" class="joystick right-joy small-joy" aria-hidden="true">
  <div class="joy-base"><div class="joy-knob" id="rightKnob"></div></div>
</div>
<!-- super joystick (menor) -->
<div id="superJoy" class="joystick super-joy small-joy" aria-hidden="true" style="display:none;">
  <div class="joy-base"><div class="joy-knob" id="superKnob"></div></div>
</div>

<script>
/* ----- Config e utilitários (motor reescrito com suporte a joysticks mobile e super) ----- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const platformOverlay = document.getElementById('platformOverlay');
const topUI = document.getElementById('topUI');
const restartBtn = document.getElementById('restartBtn');
const menuBtn = document.getElementById('menuBtn');

const chooseDesktop = document.getElementById('chooseDesktop');
const chooseMobile = document.getElementById('chooseMobile');

const leftJoyEl = document.getElementById('leftJoy');
const rightJoyEl = document.getElementById('rightJoy');
const superJoyEl = document.getElementById('superJoy');
const leftKnob = document.getElementById('leftKnob');
const rightKnob = document.getElementById('rightKnob');
const superKnob = document.getElementById('superKnob');

const WORLD = { w:1600, h:900 };
const camera = { x:0, y:0 };
let loopStarted = false;

// Velocidades aumentadas levemente conforme pedido
const CLASSES = {
  piper: { hp:300, dmg:120, speed:3.9, range:500, spread:0, shots:1, ammoRecharge:1.8, attackCooldown:1.5 },
  bull:   { hp:700, dmg:50,  speed:2.6, range:100,  spread:Math.PI/5, shots:6, ammoRecharge:2.2, attackCooldown:1.2 },
  shelly: { hp:450, dmg:60,  speed:3.4, range:250, spread:Math.PI/5, shots:5, ammoRecharge:2.0, attackCooldown:1.7 },
  mortis: { hp:400, dmg:60, speed:3.8, range:110, spread:0, shots:1, ammoRecharge:1.6, attackCooldown:2.0 },
  // COLT: 10 tiros na mesma reta, 20 de dano por bala. Super só adiciona +3 ao dano de cada bala (mecânica já suportada por fireSuper).
  colt:   { hp:420, dmg:20, speed:3.6, range:400, spread:0, shots:5, ammoRecharge:2.6, attackCooldown:2.0 },
  // NITA: alcance médio, tiro largo (largura = brawler.width). Super invoca um aliado (bola azul maior) que só ataca ao tocar inimigo ou cofre.
  nita:   { hp:450, dmg:70, speed:3.5, range:240, spread:0, shots:1, ammoRecharge:1.6, attackCooldown:1.6 }
};

let entities = [], bullets = [], bushes = [], walls = [];
let player = null;
let running = false;
let currentClass = 'piper';
let mouse = { x:0, y:0, down:false };
let keys = {};
let isMobile = false;         // plataforma escolhida

/* Cofres */
const cofre = {
  blue: { x:60, y:405, w:90, h:90, hp:5000, maxHp:5000 },
  red:  { x:WORLD.w-150, y:405, w:90, h:90, hp:5000, maxHp:5000 },
};

/* ----- Input: desktop (mouse/keyboard) ----- */
window.addEventListener('mousemove', e=>{
  if(isMobile) return;
  const r = canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  mouse.x = (e.clientX - r.left) * scaleX + camera.x;
  mouse.y = (e.clientY - r.top) * scaleY + camera.y;
});
window.addEventListener('mousedown', e=>{
  if(!isMobile && e.button===0){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width / r.width;
    const scaleY = canvas.height / r.height;
    mouse.x = (e.clientX - r.left) * scaleX + camera.x;
    mouse.y = (e.clientY - r.top) * scaleY + camera.y;
    mouse.down = true;
  }
});
window.addEventListener('mouseup', e=>{ if(!isMobile && e.button===0) mouse.down=false; });
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* Prevent context menu and use right click as Super on desktop */
window.addEventListener('contextmenu', (ev)=>{
  ev.preventDefault();
  if(isMobile) return;
  if(!player || !running || !player.alive) return;
  // compute mouse world coords from event position
  const r = canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  const mx = (ev.clientX - r.left) * scaleX + camera.x;
  const my = (ev.clientY - r.top) * scaleY + camera.y;
  const ang = Math.atan2(my - player.y, mx - player.x);
  fireSuper(player, ang);
});

/* ----- Joystick implementation (mobile) ----- */
function setJoystickVisible(visible){
  leftJoyEl.style.display = visible ? 'block' : 'none';
  rightJoyEl.style.display = visible ? 'block' : 'none';
  superJoyEl.style.display = visible ? 'block' : 'none';
}

function getCenterRect(el){
  const r = el.getBoundingClientRect();
  return { cx: r.left + r.width/2, cy: r.top + r.height/2, w: r.width, h: r.height, rect: r };
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }

/* Joystick state objects */
const leftStick = { active:false, id:null, cx:0, cy:0, max:48, vx:0, vy:0 };
const rightStick = { active:false, id:null, cx:0, cy:0, max:48, ang:0, mag:0 };
const superStick = { active:false, id:null, cx:0, cy:0, max:36, ang:0, mag:0 }; // menor

function onLeftStart(t){
  leftStick.active = true;
  leftStick.id = t.identifier;
  const c = getCenterRect(leftJoyEl);
  leftStick.cx = c.cx;
  leftStick.cy = c.cy;
  updateLeftKnob(t.clientX, t.clientY);
}
function onLeftMove(t){
  if(!leftStick.active || t.identifier !== leftStick.id) return;
  updateLeftKnob(t.clientX, t.clientY);
}
function onLeftEnd(t){
  if(!leftStick.active || t.identifier !== leftStick.id) return;
  leftStick.active = false; leftStick.id = null;
  leftStick.vx = 0; leftStick.vy = 0;
  leftKnob.style.transform = `translate(0px,0px)`;
}
function updateLeftKnob(cx, cy){
  const dx = cx - leftStick.cx;
  const dy = cy - leftStick.cy;
  const d = Math.hypot(dx,dy) || 0.0001;
  const maxd = leftStick.max;
  const nd = Math.min(d, maxd);
  const nx = dx / d * nd;
  const ny = dy / d * nd;
  leftKnob.style.transform = `translate(${nx}px, ${ny}px)`;
  leftStick.vx = (nx / maxd);
  leftStick.vy = (ny / maxd);
}

function onRightStart(t){
  rightStick.active = true;
  rightStick.id = t.identifier;
  const c = getCenterRect(rightJoyEl);
  rightStick.cx = c.cx;
  rightStick.cy = c.cy;
  updateRightKnob(t.clientX, t.clientY);
}
function onRightMove(t){
  if(!rightStick.active || t.identifier !== rightStick.id) return;
  updateRightKnob(t.clientX, t.clientY);
}
function onRightEnd(t){
  if(!rightStick.active || t.identifier !== rightStick.id) return;
  rightStick.active = false; rightStick.id = null;
  rightStick.ang = 0; rightStick.mag = 0;
  rightKnob.style.transform = `translate(0px,0px)`;
}
function updateRightKnob(cx, cy){
  const dx = cx - rightStick.cx;
  const dy = cy - rightStick.cy;
  const d = Math.hypot(dx,dy) || 0.0001;
  const maxd = rightStick.max;
  const nd = Math.min(d, maxd);
  const nx = dx / d * nd;
  const ny = dy / d * nd;
  rightKnob.style.transform = `translate(${nx}px, ${ny}px)`;
  rightStick.ang = Math.atan2(ny, nx);
  rightStick.mag = nd / maxd; // 0..1
}

/* Super joystick handlers (menor) */
function onSuperStart(t){
  superStick.active = true;
  superStick.id = t.identifier;
  const c = getCenterRect(superJoyEl);
  superStick.cx = c.cx;
  superStick.cy = c.cy;
  updateSuperKnob(t.clientX, t.clientY);
}
function onSuperMove(t){
  if(!superStick.active || t.identifier !== superStick.id) return;
  updateSuperKnob(t.clientX, t.clientY);
}
function onSuperEnd(t){
  if(!superStick.active || t.identifier !== superStick.id) return;
  // if magnitude high enough and player has super, fire it
  if(player && player.alive && player.superCharge >= 10 && superStick.mag > 0.18){
    fireSuper(player, superStick.ang);
  }
  superStick.active = false; superStick.id = null;
  superStick.ang = 0; superStick.mag = 0;
  superKnob.style.transform = `translate(0px,0px)`;
}
function updateSuperKnob(cx, cy){
  const dx = cx - superStick.cx;
  const dy = cy - superStick.cy;
  const d = Math.hypot(dx,dy) || 0.0001;
  const maxd = superStick.max;
  const nd = Math.min(d, maxd);
  const nx = dx / d * nd;
  const ny = dy / d * nd;
  superKnob.style.transform = `translate(${nx}px, ${ny}px)`;
  superStick.ang = Math.atan2(ny, nx);
  superStick.mag = nd / maxd;
}

/* Attach touch handlers to joystick elements */
leftJoyEl.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  const t = ev.changedTouches[0];
  onLeftStart(t);
}, { passive: false });
leftJoyEl.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onLeftMove(t);
}, { passive: false });
leftJoyEl.addEventListener('touchend', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onLeftEnd(t);
}, { passive: false });
leftJoyEl.addEventListener('touchcancel', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onLeftEnd(t);
}, { passive: false });

rightJoyEl.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  const t = ev.changedTouches[0];
  onRightStart(t);
}, { passive: false });
rightJoyEl.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onRightMove(t);
}, { passive: false });
rightJoyEl.addEventListener('touchend', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onRightEnd(t);
}, { passive: false });
rightJoyEl.addEventListener('touchcancel', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onRightEnd(t);
}, { passive: false });

superJoyEl.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  const t = ev.changedTouches[0];
  onSuperStart(t);
}, { passive: false });
superJoyEl.addEventListener('touchmove', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onSuperMove(t);
}, { passive: false });
superJoyEl.addEventListener('touchend', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onSuperEnd(t);
}, { passive: false });
superJoyEl.addEventListener('touchcancel', (ev)=>{
  ev.preventDefault();
  for(const t of ev.changedTouches) onSuperEnd(t);
}, { passive: false });

/* Prevent canvas default touch actions (we use joysticks instead) */
canvas.addEventListener('touchmove', e=>{ if(isMobile) e.preventDefault(); }, { passive:false });
canvas.addEventListener('touchstart', e=>{ if(isMobile) e.preventDefault(); }, { passive:false });

/* ----- Map, spawn, colisões, tiros etc (mantive o mesmo código do motor) ----- */
function createMap(){
  walls = [
    {x:780,y:200,w:40,h:200},
    {x:780,y:500,w:40,h:200},
    {x:300,y:400,w:40,h:200},
    {x:WORLD.w-340,y:400,w:40,h:200},
    {x:WORLD.w/2-260,y:120,w:120,h:40},
    {x:WORLD.w/2+140,y:740,w:120,h:40}
  ];
  bushes = [];
  const spots = [
    [400,200],[600,300],[500,500],[400,650],
    [800,150],[800,750],
    [1100,200],[1000,350],[1100,550],[1000,700],
    [600,450],[1200,450]
  ];
  spots.forEach(p => bushes.push({x:p[0], y:p[1], s:48}));
}

function spawn(team, x, y, cls, isPlayer=false){
  const def = CLASSES[cls];
  const baseSpeed = def.speed;
  const e = {
    id: Math.random().toString(36).slice(2,9),
    x,y, vx:0, vy:0,
    team, classType:cls, isPlayer,
    hp:def.hp, maxHp:def.hp, radius:14,
    // velocidade igual para bots e jogador no desktop
    speed: (!isMobile) ? (baseSpeed + 2) : baseSpeed,
    dmg:def.dmg, range:def.range, projSpeed: (def.range>300?12:10),
    shots:def.shots, spread:def.spread, attackCooldown:def.attackCooldown,
    ammoCapacity:3, ammo:3, ammoRecharge:def.ammoRecharge, lastAmmoTime: performance.now()/1000,
    lastShot:-999, lastDamagedAt:-999, alive:true, respawnAt:null,
    spawnX:x, spawnY:y, state:'idle', target:null,
    // jitter seed to break perfect symmetry
    _jit: Math.random() * Math.PI * 2,
    // offset único para flanquear/evitar todos apontarem pro mesmo pixel
    _offset: { x: (Math.random()*2-1)*60, y: (Math.random()*2-1)*60 },
    superCharge:0, // <--- super meter (0..10)
    // dash props (para Mortis)
    isDashing:false, dashEnd:0, dashVx:0, dashVy:0, dashHitSet: new Set()
  };
  entities.push(e);
  if(isPlayer) player = e;
  return e;
}

function rectCircleCollide(rx,ry,rw,rh,cx,cy,r){ const closestX = clamp(cx, rx, rx+rw); const closestY = clamp(cy, ry, ry+rh); const dx = cx-closestX; const dy = cy-closestY; return dx*dx + dy*dy <= r*r; }
function circleCircleCollide(x1,y1,r1,x2,y2,r2){ return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) <= (r1+r2)*(r1+r2); }

/* ======== ADDED: collidesWithWalls (fix para ReferenceError) ========
   Verifica colisões com cada parede e com os limites do mapa.
   Retorna true se o círculo (cx,cy,radius) colidir com paredes ou ultrapassar limites.
   =================================================================== */
function collidesWithWalls(cx, cy, radius){
  for(const w of walls){
    if(rectCircleCollide(w.x, w.y, w.w, w.h, cx, cy, radius)) return true;
  }
  if(cx - radius < 0 || cy - radius < 0 || cx + radius > WORLD.w || cy + radius > WORLD.h) return true;
  return false;
}
/* ================================================================== */

function moveAI(e, tx, ty){
  const angle = Math.atan2(ty - e.y, tx - e.x);
  const step = e.speed;
  // tenta aplicar um passo na direção desejada, usando colisão suave
  let nx = e.x + Math.cos(angle) * step;
  let ny = e.y + Math.sin(angle) * step;
  if(!collidesWithWalls(nx, ny, e.radius)){
    e.x = nx; e.y = ny; return;
  }
  const tries = [Math.PI/4, -Math.PI/4, Math.PI/8, -Math.PI/8, Math.PI/2, -Math.PI/2];
  for(const t of tries){
    const a = angle + t;
    nx = e.x + Math.cos(a) * step;
    ny = e.y + Math.sin(a) * step;
    if(!collidesWithWalls(nx, ny, e.radius)){
      e.x = nx; e.y = ny; return;
    }
  }
  // se travou, recua levemente para não empurrar para dentro da parede
  e.x += Math.cos(angle + Math.PI) * 0.8;
  e.y += Math.sin(angle + Math.PI) * 0.8;
}

/* ----- Tiro normal e Super (super = normal +3 de dano) ----- */
function startDash(e, angle, durationSec, dashSpeed, damage){
  if(!e.alive) return;
  const now = performance.now()/1000;
  e.isDashing = true;
  e.dashEnd = now + durationSec;
  e.dashVx = Math.cos(angle) * dashSpeed;
  e.dashVy = Math.sin(angle) * dashSpeed;
  e.dashHitSet = new Set();
  // Mortis dashes do not consume ammo by design (optional). Super carrega apenas quando o ataque acerta um inimigo.
}

function fire(e, angle){
  if(!e.alive) return;
  const t = performance.now()/1000;
  if(t - (e.lastShot || -999) < e.attackCooldown) return;
  if(e.ammo <= 0) return;
  e.lastShot = t;
  e.lastShotAt = t;
  e.ammo -= 1;
  e.lastAmmoTime = t;
  // cada vez que dispara (ataque normal) acumula 1 de super (max 10)

  if(e.classType === 'mortis'){
    // Mortis: realiza um curto dash que causa dano igual ao shelly ao colidir com brawlers
    // dash parameters: short duration, fast speed
    const dashDuration = 0.18; // segundos
    const dashSpeed = 14; // pixels per frame-ish (we'll move by vx/vy each update without dt for snappier dash)
    const damage = CLASSES.shelly.dmg; // dano igual ao shelly
    startDash(e, angle, dashDuration, dashSpeed, damage);
    return;
  }

  // NITA: disparo largo — raio do projétil proporcional ao tamanho do brawler
  if(e.classType === 'nita'){
    // projétil largo, r ~ brawler.radius + 2
    createBullet(e, angle, e.dmg, Math.max(6, Math.round(e.radius + 2)));
    return;
  }

  // COLT: atira os projéteis sequencialmente (um atrás do outro)
  if(e.classType === 'colt'){
    const shots = e.shots || 10;
    const intervalSec = 0.06; // intervalo entre cada tiro (em segundos)
    for(let i=0;i<shots;i++){
      (function(idx){
        setTimeout(()=>{
          // se o brawler morreu/foi desinstanciado, não atirar
          if(!e.alive) return;
          createBullet(e, angle, e.dmg);
        }, Math.round(intervalSec * 1000 * idx));
      })(i);
    }
    return;
  }

  if(e.shots === 1) createBullet(e, angle, e.dmg);
  else {
    const count = e.shots;
    for(let i=0;i<count;i++){
      const frac = (i - (count-1)/2) / ((count-1)/2 || 1);
      const a = angle + frac * (e.spread/2);
      createBullet(e, a, e.dmg);
    }
  }
}

function fireSuper(e, angle){
  if(!e.alive) return;
  if((e.superCharge || 0) < 10) return; // precisa de 10 tiros
  const t = performance.now()/1000;
  if(t - (e.lastShot || -999) < e.attackCooldown) return;
  // Super dispara mesma mecânica, mas +3 dano e consome a carga — não consome munição
  e.lastShot = t;
  e.lastShotAt = t;
  const superDmg = e.dmg + 3;
  e.superCharge = 0;

  if(e.classType === 'mortis'){
    // Mortis: super é dash mais longo e +3 de dano
    const dashDuration = 0.36; // mais longo
    const dashSpeed = 16;
    const damage = CLASSES.shelly.dmg + 3;
    startDash(e, angle, dashDuration, dashSpeed, damage);
    return;
  }

  // NITA: super invoca um aliado (bola azul mais larga). O aliado só ataca ao encostar em inimigo ou cofre.
  if(e.classType === 'nita'){
    // spawn ally a alguns pixels à frente
    createNitaBear(e, angle);
    return;
  }

  // COLT: super também dispara os 10 tiros em sequência, cada um com +3 de dano
  if(e.classType === 'colt'){
    const shots = e.shots || 10;
    const intervalSec = 0.06;
    for(let i=0;i<shots;i++){
      (function(idx){
        setTimeout(()=>{
          if(!e.alive) return;
          createBullet(e, angle, superDmg);
        }, Math.round(intervalSec * 1000 * idx));
      })(i);
    }
    return;
  }

  if(e.shots === 1) createBullet(e, angle, superDmg);
  else {
    for(let i=0;i<e.shots;i++){
      const frac = (i - (e.shots-1)/2) / ((e.shots-1)/2 || 1);
      createBullet(e, angle + frac * (e.spread/2), superDmg);
    }
  }
}

/* Create bullet accepts dmg override and optional radius */
function createBullet(e, angle, dmg, rArg){
  // Use max distance based on shooter's range so bullets stop after traveling that distance
  const projSpd = e.projSpeed || 10; // pixels per frame (kept for motion)
  const maxRange = (typeof e.range === 'number') ? e.range : 600;
  const lifeTime = Math.max(0.05, maxRange / projSpd); // fallback time-based life (seconds)
  const startX = e.x + Math.cos(angle)*(e.radius+6);
  const startY = e.y + Math.sin(angle)*(e.radius+6);
  bullets.push({
    x: startX,
    y: startY,
    vx: Math.cos(angle)*projSpd,
    vy: Math.sin(angle)*projSpd,
    born: performance.now()/1000,
    life: lifeTime,
    ownerId: e.id,
    team: e.team,
    dmg: dmg || e.dmg,
    r: (rArg !== undefined) ? rArg : 4,
    startX: startX,
    startY: startY,
    maxDist: maxRange
  });
}

/* Create Nita's bear ally */
function createNitaBear(owner, angle){
  const bx = owner.x + Math.cos(angle) * (owner.radius + 18);
  const by = owner.y + Math.sin(angle) * (owner.radius + 18);
  const bear = {
    id: 'bear_' + Math.random().toString(36).slice(2,9),
    x: bx, y: by, vx:0, vy:0,
    team: owner.team,
    classType: 'nita_bear',
    isPlayer: false,
    hp: 500,
    maxHp: 500,
    radius: Math.round(owner.radius * 1.5) + 2, // um pouco mais larga que Nita
    speed: 3.2,
    dmg: 90, // dano ao tocar
    alive: true,
    respawnAt: null, // IMPORTANT: não reaparece sozinho
    spawnX: bx, spawnY: by,
    ownerId: owner.id,
    // comportamento/estado extra para compatibilidade com o motor
    _jit: Math.random() * Math.PI * 2,
    _offset: { x: 0, y: 0 },
    lastShotAt: -999,
    lastDamagedAt: -999,
    ammoCapacity: 0,
    ammo: 0,
    ammoRecharge: 1.6,
    // mark as a special entity so other systems can treat differently
    isNitaBear: true
  };
  entities.push(bear);
}

function damageEntity(target, amount){
  if(!target.alive) return;
  target.hp -= amount;
  target.lastDamagedAt = performance.now()/1000;
  if(target.hp <= 0){
    target.alive = false;
    // se for um brawler normal, aplicamos respawn. Mas se for nita_bear, ele NÃO deve reaparecer até nova super
    if(!target.isNitaBear) target.respawnAt = performance.now()/1000 + 5.0;
    else target.respawnAt = null; // stays dead until reinvocado
  }
}
function handleRespawns(){
  const t = performance.now()/1000;
  for(const e of entities){
    if(!e.alive && e.respawnAt && t >= e.respawnAt){
      e.alive = true;
      e.hp = e.maxHp;
      e.x = e.spawnX; e.y = e.spawnY;
      e.respawnAt = null;
      e.lastDamagedAt = -999;
      e.lastShotAt = -999;
      e.ammo = e.ammoCapacity;
      e.superCharge = 0;
      // gerar novo offset único para evitar reaparecer empilhado
      e._offset = { x: (Math.random()*2-1)*60, y: (Math.random()*2-1)*60 };
      e.isDashing = false; e.dashHitSet = new Set();
    }
  }
}

function inBush(e){
  for(const b of bushes) if(e.x >= b.x && e.x <= b.x + b.s && e.y >= b.y && e.y <= b.y + b.s) return true;
  return false;
}
function isVisibleTo(src, tgt){
  if(!tgt.alive) return false;
  const revealUntil = (tgt.lastShotAt || -999) + 1.0;
  if(performance.now()/1000 <= revealUntil) return true;
  if(!inBush(tgt)) return true;
  if(dist(src.x, src.y, tgt.x, tgt.y) <= 48) return true;
  return false;
}

/* ------------------------------------------------------------------ */
/* avoidanceOffset: evita grudar em aliados, inimigos, paredes e cofres */
/* ------------------------------------------------------------------ */
function avoidanceOffset(e){
  let sx = 0, sy = 0;

  // parâmetros ajustáveis (mais agressivos para evitar empilhamento)
  const sepRadius = 72;              // raio de separação entre aliados
  const wallRepelRadius = 56;
  const cofreRepelRadius = 96;
  const sepStrength = 1.6;
  const enemyRepelStrength = 1.0;
  const wallRepelStrength = 1.6;
  const cofreRepelStrength = 1.3;

  // 1) separação de aliados (força maior e baseado em sobreposição)
  for(const other of entities){
    if(other.id === e.id) continue;
    if(!other.alive) continue;
    if(other.team !== e.team) continue;
    const d = dist(e.x, e.y, other.x, other.y);
    if(d > 0 && d < sepRadius){
      const factor = (sepRadius - d) / sepRadius;
      sx += (e.x - other.x) / d * factor * sepStrength;
      sy += (e.y - other.y) / d * factor * sepStrength;
    }
  }

  // 2) repelir inimigos se estiverem muito perto (evita empilhar em cima deles)
  for(const other of entities){
    if(other.id === e.id) continue;
    if(!other.alive) continue;
    if(other.team === e.team) continue;
    const d = dist(e.x, e.y, other.x, other.y);
    const enemyRepelRadius = 46 + e.radius + other.radius; // próximo o suficiente
    if(d > 0 && d < enemyRepelRadius){
      const factor = (enemyRepelRadius - d) / enemyRepelRadius;
      sx += (e.x - other.x) / d * factor * enemyRepelStrength;
      sy += (e.y - other.y) / d * factor * enemyRepelStrength;
    }
  }

  // 3) repelir paredes suavemente (empurra para fora antes de encostar)
  for(const w of walls){
    const closestX = clamp(e.x, w.x, w.x + w.w);
    const closestY = clamp(e.y, w.y, w.y + w.h);
    let dx = e.x - closestX, dy = e.y - closestY;
    let d = Math.hypot(dx, dy);
    if(d === 0){
      // centro do bot exatamente alinhado; empurra para cima arbitrariamente
      dx = 0; dy = -1; d = 1;
    }
    if(d < wallRepelRadius){
      const factor = (wallRepelRadius - d) / wallRepelRadius;
      sx += (dx / d) * factor * wallRepelStrength;
      sy += (dy / d) * factor * wallRepelStrength;
    }
  }

  // 4) repelir cofre para não se acumularem diretamente sobre ele
  const cofreCenters = [
    {x: cofre.blue.x + cofre.blue.w/2, y: cofre.blue.y + cofre.blue.h/2},
    {x: cofre.red.x + cofre.red.w/2, y: cofre.red.y + cofre.red.h/2}
  ];
  for(const c of cofreCenters){
    const dx = e.x - c.x, dy = e.y - c.y;
    const d = Math.hypot(dx, dy) || 0.0001;
    if(d < cofreRepelRadius){
      const factor = (cofreRepelRadius - d) / cofreRepelRadius;
      sx += (dx / d) * factor * cofreRepelStrength;
      sy += (dy / d) * factor * cofreRepelStrength;
    }
  }

  // jitter para quebrar simetria
  const t = performance.now()/1000;
  const jitter = 6;
  sx += Math.cos(t * 1.4 + e._jit) * (jitter * 0.04);
  sy += Math.sin(t * 1.9 + e._jit) * (jitter * 0.04);

  return { x: sx, y: sy };
}

/* ----- AI update: usa avoidanceOffset para desgrudar dos aliados, inimigos, paredes e cofres ----- */
function aiUpdate(e){
  if(e.isPlayer || !e.alive) return;

  // Special behaviour for Nita's bear: move towards closest enemy or enemy chest; only damage on touch (then die)
  if(e.classType === 'nita_bear'){
    const enemies = entities.filter(x => x.team !== e.team && x.alive);
    let target = null; let td = Infinity;
    for(const en of enemies){
      const d = dist(e.x, e.y, en.x, en.y);
      if(d < td){ td = d; target = en; }
    }
    // if no enemy visible, go to enemy chest
    if(!target){
      const enemyCofre = e.team === 'blue' ? cofre.red : cofre.blue;
      moveAI(e, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
      const dC = dist(e.x, e.y, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
      if(dC <= e.radius + Math.max(enemyCofre.w, enemyCofre.h)/2){
        // touch chest -> damage and die
        const dmg = e.dmg || 60;
        const enemyKey = e.team === 'blue' ? 'red' : 'blue';
        cofre[enemyKey].hp = Math.max(0, cofre[enemyKey].hp - dmg);
        e.alive = false; e.respawnAt = null; // won't respawn
      }
      return;
    }

    // move towards target
    moveAI(e, target.x, target.y);
    const d = dist(e.x, e.y, target.x, target.y);
    if(d <= e.radius + target.radius){
      // touch: apply damage and the bear dies (must be recasted by another super)
      damageEntity(target, e.dmg || 60);
      e.alive = false; e.respawnAt = null;
    }
    return;
  }

  const enemies = entities.filter(x => x.team !== e.team && x.alive);
  let closest = null; let cd = Infinity;
  for(const en of enemies){
    if(!isVisibleTo(e, en)) continue;
    const d = dist(en.x,en.y,e.x,e.y);
    if(d < cd){ cd = d; closest = en; }
  }
  const enemyCofre = e.team === 'blue' ? cofre.red : cofre.blue;

  if(e.hp / e.maxHp < 0.20){
    // fugir pro spawn (sem muita separação)
    moveAI(e, e.spawnX, e.spawnY);
    return;
  }

  // compute avoidance vector
  const avoid = avoidanceOffset(e);
  const avoidScale = 1.0;

  if (closest) {
    const d = dist(e.x,e.y,closest.x,closest.y);
    const ang = Math.atan2(closest.y - e.y, closest.x - e.x);
    // target ligeiramente deslocado pelo vetor de evasão e pelo offset único do brawler
    const targetX = closest.x + avoid.x * avoidScale + e._offset.x * 0.6;
    const targetY = closest.y + avoid.y * avoidScale + e._offset.y * 0.6;
    // mover enquanto atira
    moveAI(e, targetX, targetY);
    if(d <= e.range + 6){
      // se tem super pronto, usa super, senão normal
      if(e.superCharge >= 10) fireSuper(e, ang);
      else fire(e, ang);
    }
    return;
  }

  // sem inimigo visível: avançar para o cofre inimigo, com displacement para evitar pile-on e paredes
  const dC = dist(e.x,e.y, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
  const angC = Math.atan2((enemyCofre.y+enemyCofre.h/2)-e.y, (enemyCofre.x+enemyCofre.w/2)-e.x);
  // usa offset único para que nem todos tentem o mesmo pixel
  const targetCofreX = enemyCofre.x + enemyCofre.w/2 + avoid.x * avoidScale * 1.1 + e._offset.x * 0.9;
  const targetCofreY = enemyCofre.y + enemyCofre.h/2 + avoid.y * avoidScale * 1.1 + e._offset.y * 0.9;
  moveAI(e, targetCofreX, targetCofreY);
  if(dC <= e.range + 24){
    if(e.superCharge >= 10) fireSuper(e, angC);
    else fire(e, angC);
  }
}

// adicional: separação pós-movimento para resolver quaisquer sobreposições restantes
function separateEntities(){
  for(let i=0;i<entities.length;i++){
    const a = entities[i];
    if(!a.alive) continue;
    for(let j=i+1;j<entities.length;j++){
      const b = entities[j];
      if(!b.alive) continue;
      const d = dist(a.x,a.y,b.x,b.y);
      const minD = a.radius + b.radius + 2; // espaço mínimo entre eles
      if(d > 0 && d < minD){
        const overlap = (minD - d);
        const nx = (a.x - b.x) / d;
        const ny = (a.y - b.y) / d;
        // empurra cada um metade da sobreposição, com limites para não causar teleporte
        const push = Math.min(overlap * 0.52, 6);
        a.x += nx * push;
        a.y += ny * push;
        b.x -= nx * push;
        b.y -= ny * push;
        // garante não ficar preso em paredes
        resolveWallCollision(a);
        resolveWallCollision(b);
      }
    }
  }
}

function tickAmmo(e){
  const t = performance.now()/1000;
  if(e.ammo < e.ammoCapacity){
    if(t - (e.lastAmmoTime || 0) >= e.ammoRecharge){
      e.ammo = Math.min(e.ammoCapacity, e.ammo + 1);
      e.lastAmmoTime = t;
    }
  } else e.lastAmmoTime = t;
}
function regenTick(e, dt){
  const t = performance.now()/1000;
  const lastAction = Math.max(e.lastDamagedAt||-999, e.lastShotAt||-999);
  if(t - lastAction >= 2.0 && e.alive && e.hp < e.maxHp){
    const baseRate = 40;
    const rate = baseRate * (e.maxHp/400);
    e.hp = Math.min(e.maxHp, e.hp + rate * dt);
  }
}

function updateBullets(dt){
  const t = performance.now()/1000;
  for(let i=bullets.length-1;i>=0;i--){
    const p = bullets[i];
    p.x += p.vx;
    p.y += p.vy;
    // remove by distance (preferred) or by life time as fallback
    if(p.maxDist !== undefined){
      const travelled = Math.hypot(p.x - p.startX, p.y - p.startY);
      if(travelled >= p.maxDist){ bullets.splice(i,1); continue; }
    }
    const t = performance.now()/1000;
    if(t - p.born >= p.life){ bullets.splice(i,1); continue; }
    let hitWall = false;
    for(const w of walls) if(rectCircleCollide(w.x,w.y,w.w,w.h, p.x,p.y,p.r)) { hitWall = true; break; }
    if(hitWall){ bullets.splice(i,1); continue; }
    if(p.team === 'blue'){
      if(rectCircleCollide(cofre.red.x, cofre.red.y, cofre.red.w, cofre.red.h, p.x,p.y,p.r)){
        cofre.red.hp = Math.max(0, cofre.red.hp - p.dmg);
        bullets.splice(i,1); continue;
      }
    } else {
      if(rectCircleCollide(cofre.blue.x, cofre.blue.y, cofre.blue.w, cofre.blue.h, p.x,p.y,p.r)){
        cofre.blue.hp = Math.max(0, cofre.blue.hp - p.dmg);
        bullets.splice(i,1); continue;
      }
    }
    for(const e of entities){
      if(!e.alive) continue;
      if(e.team === p.team) continue;
      if(circleCircleCollide(p.x,p.y,p.r, e.x,e.y, e.radius)){
        damageEntity(e, p.dmg);
        // carregar super apenas quando o tiro ACERTA um inimigo
        const owner = entities.find(x => x.id === p.ownerId);
        if(owner) owner.superCharge = Math.min(10, (owner.superCharge||0) + 1);
        bullets.splice(i,1);
        break;
      }
    }
  }
}

function resolveWallCollision(e){
  for(const w of walls){
    if(rectCircleCollide(w.x,w.y,w.w,w.h, e.x,e.y,e.radius)){
      const closestX = clamp(e.x, w.x, w.x + w.w);
      const closestY = clamp(e.y, w.y, w.y + w.h);
      let dx = e.x - closestX, dy = e.y - closestY;
      let d2 = dx*dx + dy*dy;
      if(d2 === 0){
        dx = 1; dy = 0; d2 = 1;
      }
      const d = Math.sqrt(d2);
      const overlap = e.radius - d + 0.5;
      if(overlap > 0){
        e.x += (dx/d) * overlap;
        e.y += (dy/d) * overlap;
      }
    }
  }
  e.x = clamp(e.x, e.radius, WORLD.w - e.radius);
  e.y = clamp(e.y, e.radius, WORLD.h - e.radius);
}

/* ----- Atualização principal: suporte a joysticks mobile e Super ----- */
let lastTime = performance.now();
function update(){
  if(!running) return;
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  handleRespawns();

  if(player && player.alive){
    // Desktop movement (WASD)
    if(!isMobile){
      let mx = 0, my = 0;
      if(keys['w']) my -= 1;
      if(keys['s']) my += 1;
      if(keys['a']) mx -= 1;
      if(keys['d']) mx += 1;
      if(mx !== 0 || my !== 0){
        const len = Math.hypot(mx,my) || 1;
        player.x += (mx/len) * player.speed;
        player.y += (my/len) * player.speed;
        resolveWallCollision(player);
      }
      // atirar com mouse (mantido)
      if(mouse.down){
        const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        if(performance.now()/1000 - (player.lastShot || -999) >= player.attackCooldown && player.ammo > 0){
          // normal fire increments superCharge
          fire(player, ang);
        }
      }
    } else {
      // Mobile movement via left joystick
      if(leftStick.active){
        const dx = leftStick.vx, dy = leftStick.vy;
        const len = Math.hypot(dx,dy) || 1;
        player.x += (dx/len) * player.speed;
        player.y += (dy/len) * player.speed;
        resolveWallCollision(player);
      }

      // Mobile aiming + auto-fire via right joystick
      if(rightStick.active && rightStick.mag > 0.18){
        // compute world angle from joystick angle
        const ang = rightStick.ang;
        // fire respects attackCooldown and ammo inside fire()
        fire(player, ang);
      }

      // superStick handled on touchend: user aims and releases to fire super
      // (we also allow continuous super if user keeps touching and mag>threshold -> optional)
      if(superStick.active && superStick.mag > 0.95){
        // quick hold-to-fire (rare), but main firing happens on touchend.
        if(player.superCharge >= 10){
          fireSuper(player, superStick.ang);
          // prevent immediate repeat by resetting mag
          superStick.mag = 0;
          superKnob.style.transform = `translate(0px,0px)`;
          superStick.active = false;
        }
      }
    }
  }

  for(const e of entities){
    tickAmmo(e);
    regenTick(e, dt);
    if(!e.isPlayer) aiUpdate(e);

    // dash movement handling (Mortis only; but generic properties exist)
    if(e.isDashing){
      // move by dash velocity (we do not multiply by dt to keep dash snappy)
      const nextX = e.x + e.dashVx;
      const nextY = e.y + e.dashVy;
      // if next position collides with wall, end dash
      if(collidesWithWalls(nextX, nextY, e.radius)){
        e.isDashing = false;
        e.dashVx = 0; e.dashVy = 0;
        e.dashEnd = 0;
      } else {
        e.x = nextX; e.y = nextY;
        // check collisions with enemies while dashing
        for(const oth of entities){
          if(!oth.alive) continue;
          if(oth.team === e.team) continue;
          if(e.dashHitSet.has(oth.id)) continue; // already hit this dash
          if(circleCircleCollide(e.x, e.y, e.radius, oth.x, oth.y, oth.radius)){
            // damage equal to shelly or dash damage
            const damage = (e.classType === 'mortis') ? ( (e.dashDamage !== undefined) ? e.dashDamage : CLASSES.shelly.dmg ) : 0;
            damageEntity(oth, damage);
            // carregar super quando dash de Mortis acerta um inimigo
            if(e.classType === 'mortis') e.superCharge = Math.min(10, (e.superCharge||0) + 1);
            e.dashHitSet.add(oth.id);
          }
        }
        // end dash when time passes
        if(performance.now()/1000 >= e.dashEnd){
          e.isDashing = false;
          e.dashVx = 0; e.dashVy = 0; e.dashEnd = 0;
          e.dashHitSet = new Set();
        }
      }
    }
  }

  // separa entidades sobrepostas (resultado: bots não ficam grudados um no outro)
  separateEntities();

  updateBullets(dt);

  if(player){
    camera.x = clamp(player.x - canvas.width/2, 0, WORLD.w - canvas.width);
    camera.y = clamp(player.y - canvas.height/2, 0, WORLD.h - canvas.height);
  }

  if(cofre.blue.hp <= 0 || cofre.red.hp <= 0){
    running = false;
    platformOverlay.style.display = 'none';
    overlay.style.display = 'flex';
    overlay.querySelector('h2').innerText = cofre.blue.hp <= 0 ? 'Time Vermelho Venceu!' : 'Time Azul Venceu!';
    setJoystickVisible(false);
  }
}

/* ----- Desenho (mantive o visual melhorado) ----- */
function radialGradient(ctx, x, y, r, colorCenter, colorEdge){
  const g = ctx.createRadialGradient(x, y, r*0.1, x, y, r);
  g.addColorStop(0, colorCenter);
  g.addColorStop(1, colorEdge);
  return g;
}
function drawBush(b){
  const x = b.x, y = b.y, s = b.s;
  const radius = 8;
  ctx.save();
  ctx.fillStyle = '#133b16';
  roundRect(ctx, x, y, s, s, radius);
  ctx.fill();
  const leafColors = ['#1f7d2a','#1b6b24','#2aa43b','#16611d'];
  const rows = 3;
  for(let ry=0; ry<rows; ry++){
    for(let cx2=0; cx2<3; cx2++){
      const lx = x + 8 + cx2 * (s-16)/2 + (ry%2 ? 6 : 0);
      const ly = y + 8 + ry * (s-10)/rows;
      const lw = 18 + (Math.random()*6 - 3);
      const lh = 10 + (Math.random()*4 - 2);
      ctx.beginPath();
      ctx.ellipse(lx, ly, lw, lh, Math.PI * (cx2%2 ? 0.15 : -0.12), 0, Math.PI*2);
      ctx.fillStyle = leafColors[(cx2+ry) % leafColors.length];
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lx - lw*0.5, ly);
      ctx.lineTo(lx + lw*0.5, ly);
      ctx.stroke();
    }
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.28)';
  ctx.lineWidth = 1;
  roundRect(ctx, x, y, s, s, radius);
  ctx.stroke();
  ctx.restore();
}
function drawWallBlock(w){
  ctx.save();
  const g = ctx.createLinearGradient(w.x, w.y, w.x + w.w, w.y + w.h);
  g.addColorStop(0, '#6a5a42');
  g.addColorStop(1, '#564532');
  ctx.fillStyle = g;
  ctx.fillRect(w.x, w.y, w.w, w.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.lineWidth = 1;
  const rows = Math.max(2, Math.floor(w.h / 16));
  for(let i=1;i<rows;i++){
    const yy = w.y + (w.h/rows)*i;
    ctx.beginPath();
    ctx.moveTo(w.x, yy); ctx.lineTo(w.x + w.w, yy); ctx.stroke();
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.12)';
  ctx.lineWidth = 1;
  const brickH = 18;
  for(let by = w.y; by < w.y + w.h; by += brickH){
    const isOdd = Math.floor((by - w.y) / brickH) % 2 === 1;
    const step = 40;
    for(let bx = w.x - (isOdd ? step/2 : 0); bx < w.x + w.w; bx += step){
      const x0 = Math.max(w.x, bx);
      const x1 = Math.min(w.x + w.w, bx + step);
      ctx.beginPath();
      ctx.moveTo(x0, Math.min(by + brickH, w.y + w.h));
      ctx.lineTo(x1, Math.min(by + brickH, w.y + w.h));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x1, by);
      ctx.lineTo(x1, Math.min(by + brickH, w.y + w.h));
      ctx.stroke();
    }
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 2;
  ctx.strokeRect(w.x, w.y, w.w, w.h);
  ctx.restore();
}
function drawCofre(c, colorHex){
  ctx.save();
  const px = c.x, py = c.y, pw = c.w, ph = c.h;
  const g = ctx.createLinearGradient(px, py, px, py + ph);
  g.addColorStop(0, shade(colorHex, 0.12));
  g.addColorStop(1, shade(colorHex, -0.08));
  ctx.fillStyle = g;
  roundRect(ctx, px, py, pw, ph, 6);
  ctx.fill();
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  roundRect(ctx, px + pw*0.08, py + ph*0.12, pw*0.84, ph*0.76, 4);
  ctx.fill();
  const lidH = ph * 0.28;
  const lg = ctx.createLinearGradient(px, py, px, py + lidH);
  lg.addColorStop(0, '#ffffff20');
  lg.addColorStop(1, '#00000010');
  ctx.fillStyle = lg;
  roundRect(ctx, px, py, pw, lidH, 6);
  ctx.fill();
  const lockX = px + pw/2;
  const lockY = py + ph/2 + 4;
  ctx.fillStyle = '#bfa86a';
  ctx.beginPath();
  ctx.ellipse(lockX, lockY, 10, 12, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#7a5f3a';
  ctx.fillRect(lockX - 4, lockY - 2, 8, 4);
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  const rivets = [
    [px + 8, py + 8],[px + pw - 8, py + 8],
    [px + 8, py + ph - 8],[px + pw - 8, py + ph - 8]
  ];
  for(const r of rivets){
    ctx.beginPath();
    ctx.arc(r[0], r[1], 3, 0, Math.PI*2);
    ctx.fill();
  }
  const barW = 180;
  const bx = px + pw/2 - barW/2;
  const by = py - 18;
  ctx.fillStyle = 'rgba(0,0,0,0.66)'; ctx.fillRect(bx,by,barW,10);
  const ratio = c.hp / c.maxHp;
  ctx.fillStyle = ratio>0.5 ? '#2b8' : (ratio>0.2 ? '#fa0' : '#f33');
  ctx.fillRect(bx+2, by+2, (barW-4) * clamp(ratio,0,1), 6);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(bx,by,barW,10);
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Cofre', px + pw/2, py + ph + 14);
  ctx.restore();
}
function drawBrawler(e){
  ctx.save();
  const alpha = inBush(e) ? 0.62 : 1.0;
  ctx.globalAlpha = alpha;
  const cx = e.x, cy = e.y, r = e.radius;
  let centerColor = e.team === 'blue' ? '#2f9cff' : '#ff5555';
  let edgeColor = shade(centerColor, -0.25);

  // se estiver dashando, desenhar um traço rápido atrás dele
  if(e.isDashing){
    ctx.beginPath();
    ctx.moveTo(cx - e.dashVx*1.2, cy - e.dashVy*1.2);
    ctx.lineTo(cx, cy);
    ctx.lineWidth = 10;
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.stroke();
  }

  // Special draw for Nita's bear
  if(e.classType === 'nita_bear'){
    ctx.beginPath();
    // blue-ish ball for the ally
    ctx.fillStyle = radialGradient(ctx, cx - r*0.2, cy - r*0.3, r, '#6fb7ff', '#1a6fb0');
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.stroke();
    // little shine
    ctx.beginPath(); ctx.ellipse(cx - r*0.25, cy - r*0.25, r*0.6, r*0.45, -0.3, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fill();
    ctx.restore();
    return;
  }

  ctx.beginPath();
  ctx.fillStyle = radialGradient(ctx, cx - r*0.3, cy - r*0.4, r, centerColor, edgeColor);
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.ellipse(cx - r*0.25, cy - r*0.15, r*0.8, r*0.6, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(cx - 4, cy - 2, 2.6, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx + 4, cy - 2, 2.6, 0, Math.PI*2);
  ctx.fill();
  if(e.classType === 'bull'){
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.rect(cx - r*0.7, cy + r*0.2, r*1.4, 3);
    ctx.fill();
  } else if(e.classType === 'piper'){
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath();
    ctx.rect(cx - r*0.2, cy - r*0.9, r*0.4, 6);
    ctx.fill();
  } else if(e.classType === 'mortis'){
    // pequena indicação visual (capuz)
    ctx.beginPath();
    ctx.moveTo(cx - r*0.8, cy - r*0.4);
    ctx.quadraticCurveTo(cx, cy - r*1.2, cx + r*0.8, cy - r*0.4);
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fill();
  } else if(e.classType === 'colt'){
    // pequeno traço para Colt (indicando cano)
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(cx + r*0.5, cy - 2, r, 4);
  } else if(e.classType === 'nita'){
    // simple visual tweak for Nita: small ear/mark
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath(); ctx.arc(cx - r*0.35, cy - r*0.6, r*0.25, 0, Math.PI*2); ctx.fill();
  }
  const hpRatio = e.hp / e.maxHp;
  const bw = e.radius * 2.8;
  const bx = e.x - bw/2, by = e.y - e.radius - 12;
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(bx,by,bw,8);
  ctx.fillStyle = hpRatio>0.5 ? '#2b8' : (hpRatio>0.2 ? '#fa0' : '#f33');
  ctx.fillRect(bx+1, by+1, (bw-2) * clamp(hpRatio,0,1), 6);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(bx,by,bw,8);
  const ammoX = e.x - 12, ammoY = e.y + e.radius + 8;
  for(let a=0;a<e.ammoCapacity;a++){
    ctx.beginPath();
    ctx.fillStyle = a < e.ammo ? '#ffeb3b' : 'rgba(255,255,255,0.18)';
    ctx.arc(ammoX + a*11, ammoY, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();
  }
  // mostra carga de super sobre o brawler (para o jogador é útil)
  if(e.isPlayer){
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Super: ${Math.floor(e.superCharge||0)}/10`, e.x, e.y - e.radius - 22);
  }
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}
function shade(hex, percent){
  const f = hex.slice(1);
  const r = parseInt(f.substring(0,2),16);
  const g = parseInt(f.substring(2,4),16);
  const b = parseInt(f.substring(4,6),16);
  const t = percent < 0 ? 0 : 255;
  const p = Math.abs(percent);
  const nr = Math.round((t - r)*p) + r;
  const ng = Math.round((t - g)*p) + g;
  const nb = Math.round((t - b)*p) + b;
  return `rgb(${nr},${ng},${nb})`;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  ctx.fillStyle = '#5a9';
  ctx.fillRect(0,0,WORLD.w,WORLD.h);
  for(let i=0;i<60;i++){
    ctx.fillStyle = 'rgba(0,0,0,0.02)';
    ctx.fillRect(30 + i*24, 30 + (i%7)*40, 2, 2);
  }
  for(const b of bushes) drawBush(b);
  for(const w of walls) drawWallBlock(w);
  drawCofre(cofre.blue, '#2f9cff');
  drawCofre(cofre.red, '#ff5555');

  for(const p of bullets){
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,238,120,0.98)';
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.arc(p.x - p.vx*0.12, p.y - p.vy*0.12, p.r*0.8, 0, Math.PI*2);
    ctx.fill();
  }

  for(const e of entities) if(e.alive) drawBrawler(e);

  for(const e of entities){
    if(e.alive) continue;
    if(e.respawnAt){
      const left = Math.max(0, Math.ceil(e.respawnAt - performance.now()/1000));
      ctx.beginPath();
      ctx.fillStyle = e.team === 'blue' ? '#2f9cff' : '#ff5555';
      ctx.arc(e.spawnX, e.spawnY, 10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(left, e.spawnX, e.spawnY);
    }
  }

  ctx.restore();

  // crosshair (desktop): desenha uma mira na posição do mouse (coordenadas de tela)
  if(!isMobile && running && typeof mouse.x === 'number'){
    const sx = mouse.x - camera.x;
    const sy = mouse.y - camera.y;
    ctx.save();
    // círculo externo sutil
    ctx.beginPath();
    ctx.arc(sx, sy, 10, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // linhas da mira
    ctx.beginPath();
    ctx.moveTo(sx - 14, sy);
    ctx.lineTo(sx - 6, sy);
    ctx.moveTo(sx + 6, sy);
    ctx.lineTo(sx + 14, sy);
    ctx.moveTo(sx, sy - 14);
    ctx.lineTo(sx, sy - 6);
    ctx.moveTo(sx, sy + 6);
    ctx.lineTo(sx, sy + 14);
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.resume;
    ctx.restore();
  }

  // Top UI: cofres + Super do jogador
  let superText = '';
  if(player) superText = ` &nbsp;&nbsp; — &nbsp;&nbsp; Super: ${Math.floor(player.superCharge||0)}/10`;
  topUI.innerHTML = `<span class="cofre-dot cofre-blue"></span> Cofre Azul: ${Math.max(0, Math.round(cofre.blue.hp))} &nbsp;&nbsp; — &nbsp;&nbsp; <span class="cofre-dot cofre-red"></span> Cofre Vermelho: ${Math.max(0, Math.round(cofre.red.hp))}${superText}`;
}

/* ----- Loop principal ----- */
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

/* ----- Iniciar/Resetar jogo ----- */
function clearState(){
  entities = []; bullets = []; bushes = []; walls = [];
  player = null;
  cofre.blue.hp = cofre.blue.maxHp;
  cofre.red.hp = cofre.red.maxHp;
}

function spawnTeams(chosenClass){
  const blueSpawnX = cofre.blue.x + cofre.blue.w + 40, blueSpawnY = cofre.blue.y + cofre.blue.h/2;
  const redSpawnX = cofre.red.x - 40, redSpawnY = cofre.red.y + cofre.red.h/2;
  spawn('blue', blueSpawnX, blueSpawnY-60, chosenClass, true);
  spawn('blue', blueSpawnX, blueSpawnY + 20, 'shelly');
  spawn('blue', blueSpawnX, blueSpawnY + 100, 'bull');
  // coloquei um Colt no time inimigo para testar a nova classe também
  spawn('red', redSpawnX, redSpawnY-100, 'colt');
  spawn('red', redSpawnX, redSpawnY + 20, 'shelly');
  spawn('red', redSpawnX, redSpawnY + 100, 'bull');
}

function startGame(chosenClass){
  currentClass = chosenClass || currentClass;
  platformOverlay.style.display = 'none';
  overlay.style.display = 'none';
  clearState();
  createMap();
  spawnTeams(currentClass);
  cofre.blue.hp = cofre.blue.maxHp = 5000;
  cofre.red.hp = cofre.red.maxHp = 5000;
  running = true;
  lastTime = performance.now();
  // Exibir joysticks somente se o usuário escolheu mobile
  setJoystickVisible(isMobile && running);
  if(!loopStarted){ loopStarted = true; gameLoop(); }
}

/* Restart */
function restartGame(){
  running = false;
  setTimeout(()=>{
    startGame(currentClass);
  }, 60);
}
restartBtn.addEventListener('click', restartGame);

/* Menu: volta para escolha de plataforma (assim o jogador pode trocar) */
menuBtn.addEventListener('click', ()=>{
  running = false;
  platformOverlay.style.display = 'flex';
  overlay.style.display = 'none';
  setJoystickVisible(false);
});

/* Platform choice clicks */
chooseDesktop.addEventListener('click', ()=>{
  isMobile = false;
  document.body.classList.remove('is-mobile');
  platformOverlay.style.display = 'none';
  overlay.style.display = 'flex';
  setJoystickVisible(false);
});
chooseMobile.addEventListener('click', ()=>{
  isMobile = true;
  document.body.classList.add('is-mobile');
  platformOverlay.style.display = 'none';
  overlay.style.display = 'flex';
  setJoystickVisible(false); // aguardamos startGame para mostrar
});

/* Inicial */
createMap();
platformOverlay.style.display = 'flex';

/* Ajuste de dimensionamento do canvas para ficar consistente com CSS */
function resizeCanvasToDisplaySize(){
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(300, Math.floor(rect.width));
  const h = Math.max(200, Math.floor(rect.height));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
}
window.addEventListener('resize', ()=>{ resizeCanvasToDisplaySize(); });
resizeCanvasToDisplaySize();

/* Utilities: quando o overlay some e o jogo começa, garantir joysticks se mobile */
const observer = new MutationObserver(()=>{ resizeCanvasToDisplaySize(); });
observer.observe(document.body, { attributes: true, childList: true, subtree: true });

</script>
</body>
</html>
