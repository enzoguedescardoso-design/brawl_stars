<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<title>MOBA Heist MVP — Mobile / Desktop (Velocidade Corrigida)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
  :root{
    --bg-1: #071326;
    --bg-2: #06364a;
    --accent: #2f9cff;
    --accent-2: #ff6b6b;
    --panel: rgba(18,20,23,0.82);
    --glass: rgba(255,255,255,0.04);
    --muted: rgba(255,255,255,0.75);
    --card: rgba(255,255,255,0.03);
    --glass-strong: rgba(255,255,255,0.06);
    --shadow: 0 10px 30px rgba(2,8,23,0.6);
    --radius: 12px;
    --glass-blur: 6px;
  }

  * { box-sizing: border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: linear-gradient(180deg,var(--bg-1), var(--bg-2)); color:var(--muted); -webkit-tap-highlight-color: transparent; }

  #app-wrap { display:flex; height:100vh; align-items:center; justify-content:center; gap:20px; padding:18px; position:relative; }

  canvas {
    display:block;
    width:100%;
    max-width:880px;
    aspect-ratio: 4/3;
    border-radius:14px;
    box-shadow: var(--shadow), 0 2px 8px rgba(0,0,0,0.45);
    border: 1px solid rgba(255,255,255,0.04);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
    image-rendering: optimizeSpeed;
    transform-origin: center;
  }

  #topUI{
    position: absolute;
    top:18px;
    left:50%;
    transform: translateX(-50%);
    z-index:30;
    background: linear-gradient(180deg, rgba(0,0,0,0.45), rgba(255,255,255,0.02));
    padding:8px 16px;
    border-radius:999px;
    font-weight:700;
    font-size:14px;
    letter-spacing:0.4px;
    border:1px solid rgba(255,255,255,0.04);
    box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    color: #f7fbff;
  }

  #controls{
    position: absolute;
    top:10px;
    right:12px;
    z-index:30;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .btn {
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.06));
    color: #eaf6ff;
    padding:8px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.06);
    cursor:pointer;
    font-weight:800;
    font-size:13px;
    letter-spacing:0.6px;
    box-shadow: 0 4px 14px rgba(2,8,23,0.45);
    transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    backdrop-filter: blur(var(--glass-blur));
    -webkit-user-select: none; user-select: none;
  }
  .btn:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(2,8,23,0.6); }
  .btn:active { transform: translateY(-1px) scale(0.995); }

  /* overlays (platform choice + class selection) */
  .overlay {
    position: absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(3,6,10,0.66), rgba(3,6,10,0.82));
    z-index:60;
    padding:20px;
  }
  .card-panel {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
    border-radius:16px;
    padding:22px;
    min-width:320px;
    box-shadow: 0 18px 50px rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.04);
    text-align:center;
  }
  .choice-row { display:flex; gap:12px; justify-content:center; margin-top:10px; flex-wrap:wrap; }
  .choice {
    padding:12px 16px;
    border-radius:12px;
    cursor:pointer;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border:1px solid rgba(255,255,255,0.04);
    font-weight:800;
    color:#eaf6ff;
    min-width:120px;
  }
  .choice:active { transform:scale(0.99); }

  .cofre-dot { display:inline-block; width:9px; height:9px; border-radius:50%; margin-right:8px; vertical-align:middle; box-shadow: 0 2px 6px rgba(0,0,0,0.6); }
  .cofre-blue { background: var(--accent); }
  .cofre-red { background: var(--accent-2); }

  @media (max-width:720px){
    #controls { top:8px; right:8px; }
    .card-panel { width:90vw; min-width:unset; }
  }
</style>
</head>
<body>
<div id="app-wrap">
  <canvas id="c" width="1000" height="750"></canvas>
</div>

<div id="topUI"></div>

<div id="controls">
  <button id="restartBtn" class="btn">Reiniciar</button>
  <button id="menuBtn" class="btn">Menu</button>
</div>

<!-- Platform selection overlay (appears first) -->
<div id="platformOverlay" class="overlay" style="display:flex;">
  <div class="card-panel">
    <h2 style="margin:0 0 10px 0; color:#eaf6ff">Você está jogando em:</h2>
    <div class="choice-row">
      <div class="choice" id="chooseDesktop">Computador (Teclado + Mouse)</div>
      <div class="choice" id="chooseMobile">Mobile (Toque)</div>
    </div>
    <div style="margin-top:12px; color:rgba(230,245,255,0.85); font-size:13px">Escolha a plataforma para ajustar os controles.</div>
  </div>
</div>

<!-- Class selection overlay (aparece depois de escolher plataforma) -->
<div id="overlay" class="overlay" style="display:none;">
  <div class="card-panel">
    <h2 style="margin:0 0 8px 0">Escolha sua classe</h2>
    <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
      <div class="choice" onclick="startGame('sniper')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Sniper</div>
        <small style="display:block; margin-top:4px; font-weight:700">Long range • baixo HP</small>
      </div>
      <div class="choice" onclick="startGame('tank')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Tank</div>
        <small style="display:block; margin-top:4px; font-weight:700">Alta vida • curto alcance</small>
      </div>
      <div class="choice" onclick="startGame('shotgun')">
        <div style="font-size:16px; font-weight:900; margin-bottom:4px;">Shotgun</div>
        <small style="display:block; margin-top:4px; font-weight:700">Ataque em cone • médio</small>
      </div>
    </div>
    <div style="text-align:center; margin-top:10px; font-size:13px; opacity:0.95">
      Controles Desktop: <strong>W A S D</strong> para mover • Mouse para mirar • Clique esquerdo para atirar
      <br/>
      Controles Mobile: toque e segure na tela para mover; solte para atirar.
    </div>
  </div>
</div>

<script>
/* ----- Config e utilitários (motor reescrito com pequenas correções para mobile) ----- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const platformOverlay = document.getElementById('platformOverlay');
const topUI = document.getElementById('topUI');
const restartBtn = document.getElementById('restartBtn');
const menuBtn = document.getElementById('menuBtn');

const chooseDesktop = document.getElementById('chooseDesktop');
const chooseMobile = document.getElementById('chooseMobile');

const WORLD = { w:1600, h:900 };
const camera = { x:0, y:0 };
let loopStarted = false;

// Velocidades aumentadas levemente conforme pedido
const CLASSES = {
  sniper: { hp:300, dmg:120, speed:3.9, range:550, spread:0, shots:1, ammoRecharge:1.8, attackCooldown:0.4 },
  tank:   { hp:700, dmg:50,  speed:2.6, range:80,  spread:0, shots:1, ammoRecharge:2.2, attackCooldown:0.6 },
  shotgun:{ hp:450, dmg:60,  speed:3.4, range:160, spread:Math.PI/5, shots:5, ammoRecharge:2.0, attackCooldown:0.9 }
};

let entities = [], bullets = [], bushes = [], walls = [];
let player = null;
let running = false;
let currentClass = 'sniper';
let mouse = { x:0, y:0, down:false };
let keys = {};
let isMobile = false;         // plataforma escolhida
let touchState = { active:false, x:0, y:0 }; // guarda a posição de toque mais recente

/* Cofres */
const cofre = {
  blue: { x:60, y:405, w:90, h:90, hp:5000, maxHp:5000 },
  red:  { x:WORLD.w-150, y:405, w:90, h:90, hp:5000, maxHp:5000 },
};

/* ----- Input: desktop (mouse/keyboard) ----- */
window.addEventListener('mousemove', e=>{
  if(isMobile) return;
  const r = canvas.getBoundingClientRect();
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  mouse.x = (e.clientX - r.left) * scaleX + camera.x;
  mouse.y = (e.clientY - r.top) * scaleY + camera.y;
});
window.addEventListener('mousedown', e=>{
  if(!isMobile && e.button===0){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width / r.width;
    const scaleY = canvas.height / r.height;
    mouse.x = (e.clientX - r.left) * scaleX + camera.x;
    mouse.y = (e.clientY - r.top) * scaleY + camera.y;
    mouse.down = true;
  }
});
window.addEventListener('mouseup', e=>{ if(!isMobile && e.button===0) mouse.down=false; });
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* ----- Input: mobile (touch) ----- */
function touchToWorld(t){
  const r = canvas.getBoundingClientRect();
  // corrige para canvas escalado (CSS) ou dispositivos HiDPI
  const scaleX = canvas.width / r.width;
  const scaleY = canvas.height / r.height;
  const tx = (t.clientX - r.left) * scaleX + camera.x;
  const ty = (t.clientY - r.top) * scaleY + camera.y;
  return { x: tx, y: ty };
}
canvas.addEventListener('touchstart', e=>{
  if(!isMobile) return;
  e.preventDefault();
  const t = e.touches[0];
  const w = touchToWorld(t);
  touchState.active = true;
  touchState.x = w.x; touchState.y = w.y;
  mouse.x = w.x; mouse.y = w.y; mouse.down = true;
}, { passive: false });
canvas.addEventListener('touchmove', e=>{
  if(!isMobile) return;
  e.preventDefault();
  const t = e.touches[0];
  const w = touchToWorld(t);
  touchState.x = w.x; touchState.y = w.y;
  mouse.x = w.x; mouse.y = w.y;
}, { passive: false });

// touchend: o tiro acontece ao SOLTAR o dedo (apenas 1 tiro por soltada se as condições permitirem)
canvas.addEventListener('touchend', e=>{
  if(!isMobile) return;
  e.preventDefault();

  // faz o disparo em direção à última posição conhecida do toque
  if(player && player.alive){
    const ang = Math.atan2(
      touchState.y - player.y,
      touchState.x - player.x
    );

    const tnow = performance.now()/1000;
    if(tnow - (player.lastShot || -999) >= player.attackCooldown && player.ammo > 0){
      player.lastShot = tnow;
      player.lastShotAt = tnow;
      player.ammo -= 1;
      player.lastAmmoTime = tnow;

      if(player.shots === 1){
        createBullet(player, ang);
      } else {
        for(let i=0;i<player.shots;i++){
          const frac = (i - (player.shots-1)/2) / ((player.shots-1)/2 || 1);
          createBullet(player, ang + frac * (player.spread/2));
        }
      }
    }
  }

  touchState.active = false;
  mouse.down = false;
}, { passive: false });

canvas.addEventListener('touchcancel', e=>{
  if(!isMobile) return;
  e.preventDefault();
  touchState.active = false;
  mouse.down = false;
}, { passive: false });

/* ----- Map, spawn, colisões, tiros etc (mantive o mesmo código do motor) ----- */
function createMap(){
  walls = [
    {x:780,y:200,w:40,h:200},
    {x:780,y:500,w:40,h:200},
    {x:300,y:400,w:40,h:200},
    {x:WORLD.w-340,y:400,w:40,h:200},
    {x:WORLD.w/2-260,y:120,w:120,h:40},
    {x:WORLD.w/2+140,y:740,w:120,h:40}
  ];
  bushes = [];
  const spots = [
    [400,200],[600,300],[500,500],[400,650],
    [800,150],[800,750],
    [1100,200],[1000,350],[1100,550],[1000,700],
    [600,450],[1200,450]
  ];
  spots.forEach(p => bushes.push({x:p[0], y:p[1], s:48}));
}

function spawn(team, x, y, cls, isPlayer=false){
  const def = CLASSES[cls];
  const baseSpeed = def.speed;
  const e = {
    id: Math.random().toString(36).slice(2,9),
    x,y, vx:0, vy:0,
    team, classType:cls, isPlayer,
    hp:def.hp, maxHp:def.hp, radius:14,
    // Se for o jogador e estivermos em desktop (isMobile === false), aumente a velocidade em +5
    speed: (isPlayer && !isMobile) ? (baseSpeed + 2) : baseSpeed,
    dmg:def.dmg, range:def.range, projSpeed: (def.range>300?12:10),
    shots:def.shots, spread:def.spread, attackCooldown:def.attackCooldown,
    ammoCapacity:3, ammo:3, ammoRecharge:def.ammoRecharge, lastAmmoTime: performance.now()/1000,
    lastShot:-999, lastDamagedAt:-999, alive:true, respawnAt:null,
    spawnX:x, spawnY:y, state:'idle', target:null
  };
  entities.push(e);
  if(isPlayer) player = e;
  return e;
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function rectCircleCollide(rx,ry,rw,rh,cx,cy,r){ const closestX = clamp(cx, rx, rx+rw); const closestY = clamp(cy, ry, ry+rh); const dx = cx-closestX; const dy = cy-closestY; return dx*dx + dy*dy <= r*r; }
function circleCircleCollide(x1,y1,r1,x2,y2,r2){ return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) <= (r1+r2)*(r1+r2); }

function moveAI(e, tx, ty){
  const angle = Math.atan2(ty - e.y, tx - e.x);
  const step = e.speed;
  let nx = e.x + Math.cos(angle) * step;
  let ny = e.y + Math.sin(angle) * step;
  if(!collidesWithWalls(nx, ny, e.radius)){
    e.x = nx; e.y = ny; return;
  }
  const tries = [Math.PI/4, -Math.PI/4, Math.PI/8, -Math.PI/8, Math.PI/2, -Math.PI/2];
  for(const t of tries){
    const a = angle + t;
    nx = e.x + Math.cos(a) * step;
    ny = e.y + Math.sin(a) * step;
    if(!collidesWithWalls(nx, ny, e.radius)){
      e.x = nx; e.y = ny; return;
    }
  }
  e.x += Math.cos(angle + Math.PI) * 0.8;
  e.y += Math.sin(angle + Math.PI) * 0.8;
}

function collidesWithWalls(x, y, radius){
  for(const w of walls) if(rectCircleCollide(w.x, w.y, w.w, w.h, x, y, radius)) return true;
  if(x - radius < 0 || y - radius < 0 || x + radius > WORLD.w || y + radius > WORLD.h) return true;
  return false;
}

function fire(e, angle){
  if(!e.alive) return;
  const t = performance.now()/1000;
  if(t - e.lastShot < e.attackCooldown) return;
  if(e.ammo <= 0) return;
  e.lastShot = t;
  e.lastShotAt = t;
  e.ammo -= 1;
  e.lastAmmoTime = t;
  if(e.shots === 1) createBullet(e, angle);
  else {
    const count = e.shots;
    for(let i=0;i<count;i++){
      const frac = (i - (count-1)/2) / ((count-1)/2 || 1);
      const a = angle + frac * (e.spread/2);
      createBullet(e, a);
    }
  }
}
function createBullet(e, angle){
  bullets.push({
    x: e.x + Math.cos(angle)*(e.radius+6),
    y: e.y + Math.sin(angle)*(e.radius+6),
    vx: Math.cos(angle)*(e.projSpeed || 10),
    vy: Math.sin(angle)*(e.projSpeed || 10),
    born: performance.now()/1000,
    life: 3.0,
    ownerId: e.id,
    team: e.team,
    dmg: e.dmg,
    r: 4
  });
}

function damageEntity(target, amount){
  if(!target.alive) return;
  target.hp -= amount;
  target.lastDamagedAt = performance.now()/1000;
  if(target.hp <= 0){
    target.alive = false;
    target.respawnAt = performance.now()/1000 + 5.0;
  }
}
function handleRespawns(){
  const t = performance.now()/1000;
  for(const e of entities){
    if(!e.alive && e.respawnAt && t >= e.respawnAt){
      e.alive = true;
      e.hp = e.maxHp;
      e.x = e.spawnX; e.y = e.spawnY;
      e.respawnAt = null;
      e.lastDamagedAt = -999;
      e.lastShotAt = -999;
      e.ammo = e.ammoCapacity;
    }
  }
}

function inBush(e){
  for(const b of bushes) if(e.x >= b.x && e.x <= b.x + b.s && e.y >= b.y && e.y <= b.y + b.s) return true;
  return false;
}
function isVisibleTo(src, tgt){
  if(!tgt.alive) return false;
  const revealUntil = (tgt.lastShotAt || -999) + 1.0;
  if(performance.now()/1000 <= revealUntil) return true;
  if(!inBush(tgt)) return true;
  if(dist(src.x, src.y, tgt.x, tgt.y) <= 48) return true;
  return false;
}

function aiUpdate(e){
  if(e.isPlayer || !e.alive) return;
  const enemies = entities.filter(x => x.team !== e.team && x.alive);
  let closest = null; let cd = Infinity;
  for(const en of enemies){
    if(!isVisibleTo(e, en)) continue;
    const d = dist(e.x,e.y,en.x,en.y);
    if(d < cd){ cd = d; closest = en; }
  }
  const myCofre = e.team === 'blue' ? cofre.blue : cofre.red;
  const enemyCofre = e.team === 'blue' ? cofre.red : cofre.blue;
  if(e.hp / e.maxHp < 0.20){
    moveAI(e, e.spawnX, e.spawnY);
    return;
  }
  if(closest){
    const d = dist(e.x,e.y,closest.x,closest.y);
    if(d <= e.range + 6){
      const ang = Math.atan2(closest.y - e.y, closest.x - e.x);
      fire(e, ang);
    } else {
      moveAI(e, closest.x, closest.y);
    }
    return;
  }
  const dC = dist(e.x,e.y, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
  if(dC <= e.range + 24){
    const ang = Math.atan2((enemyCofre.y+enemyCofre.h/2)-e.y, (enemyCofre.x+enemyCofre.w/2)-e.x);
    fire(e, ang);
  } else {
    moveAI(e, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
  }
}

function tickAmmo(e){
  const t = performance.now()/1000;
  if(e.ammo < e.ammoCapacity){
    if(t - (e.lastAmmoTime || 0) >= e.ammoRecharge){
      e.ammo = Math.min(e.ammoCapacity, e.ammo + 1);
      e.lastAmmoTime = t;
    }
  } else e.lastAmmoTime = t;
}
function regenTick(e, dt){
  const t = performance.now()/1000;
  const lastAction = Math.max(e.lastDamagedAt||-999, e.lastShotAt||-999);
  if(t - lastAction >= 2.0 && e.alive && e.hp < e.maxHp){
    const baseRate = 40;
    const rate = baseRate * (e.maxHp/400);
    e.hp = Math.min(e.maxHp, e.hp + rate * dt);
  }
}

function updateBullets(dt){
  const t = performance.now()/1000;
  for(let i=bullets.length-1;i>=0;i--){
    const p = bullets[i];
    p.x += p.vx;
    p.y += p.vy;
    if(t - p.born >= p.life){ bullets.splice(i,1); continue; }
    let hitWall = false;
    for(const w of walls) if(rectCircleCollide(w.x,w.y,w.w,w.h, p.x,p.y,p.r)) { hitWall = true; break; }
    if(hitWall){ bullets.splice(i,1); continue; }
    if(p.team === 'blue'){
      if(rectCircleCollide(cofre.red.x, cofre.red.y, cofre.red.w, cofre.red.h, p.x,p.y,p.r)){
        cofre.red.hp = Math.max(0, cofre.red.hp - p.dmg);
        bullets.splice(i,1); continue;
      }
    } else {
      if(rectCircleCollide(cofre.blue.x, cofre.blue.y, cofre.blue.w, cofre.blue.h, p.x,p.y,p.r)){
        cofre.blue.hp = Math.max(0, cofre.blue.hp - p.dmg);
        bullets.splice(i,1); continue;
      }
    }
    for(const e of entities){
      if(!e.alive) continue;
      if(e.team === p.team) continue;
      if(circleCircleCollide(p.x,p.y,p.r, e.x,e.y, e.radius)){
        damageEntity(e, p.dmg);
        bullets.splice(i,1);
        break;
      }
    }
  }
}

function resolveWallCollision(e){
  for(const w of walls){
    if(rectCircleCollide(w.x,w.y,w.w,w.h, e.x,e.y,e.radius)){
      const closestX = clamp(e.x, w.x, w.x + w.w);
      const closestY = clamp(e.y, w.y, w.y + w.h);
      let dx = e.x - closestX, dy = e.y - closestY;
      let d2 = dx*dx + dy*dy;
      if(d2 === 0){
        dx = 1; dy = 0; d2 = 1;
      }
      const d = Math.sqrt(d2);
      const overlap = e.radius - d + 0.5;
      if(overlap > 0){
        e.x += (dx/d) * overlap;
        e.y += (dy/d) * overlap;
      }
    }
  }
  e.x = clamp(e.x, e.radius, WORLD.w - e.radius);
  e.y = clamp(e.y, e.radius, WORLD.h - e.radius);
}

/* ----- Atualização principal: agora com suporte a mobile touch movement, mas sem atirar enquanto segura ----- */
let lastTime = performance.now();
function update(){
  if(!running) return;
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  handleRespawns();

  if(player && player.alive){
    // Desktop movement (WASD)
    if(!isMobile){
      let mx = 0, my = 0;
      if(keys['w']) my -= 1;
      if(keys['s']) my += 1;
      if(keys['a']) mx -= 1;
      if(keys['d']) mx += 1;
      if(mx !== 0 || my !== 0){
        const len = Math.hypot(mx,my) || 1;
        player.x += (mx/len) * player.speed;
        player.y += (my/len) * player.speed;
        resolveWallCollision(player);
      }
      // atirar com mouse (mantido)
      if(mouse.down){
        const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        if(performance.now()/1000 - (player.lastShot || -999) >= player.attackCooldown && player.ammo > 0){
          player.lastShot = performance.now()/1000;
          player.lastShotAt = performance.now()/1000;
          player.ammo -= 1;
          player.lastAmmoTime = performance.now()/1000;
          if(player.shots === 1) createBullet(player, ang);
          else {
            for(let i=0;i<player.shots;i++){
              const frac = (i - (player.shots-1)/2) / ((player.shots-1)/2 || 1);
              createBullet(player, ang + frac * (player.spread/2));
            }
          }
        }
      }
    } else {
      // Mobile behaviour: se estiver tocando -> mover em direção ao toque (sem atirar enquanto segura)
      if(touchState.active){
        const dx = touchState.x - player.x;
        const dy = touchState.y - player.y;
        const len = Math.hypot(dx,dy) || 1;
        player.x += (dx/len) * player.speed;
        player.y += (dy/len) * player.speed;
        resolveWallCollision(player);
        // NÃO atira aqui — o disparo acontece ao soltar (touchend)
      } else {
        // sem toque: não mexe nem atira
      }
    }
  }

  for(const e of entities){
    tickAmmo(e);
    regenTick(e, dt);
    if(!e.isPlayer) aiUpdate(e);
  }

  updateBullets(dt);

  if(player){
    camera.x = clamp(player.x - canvas.width/2, 0, WORLD.w - canvas.width);
    camera.y = clamp(player.y - canvas.height/2, 0, WORLD.h - canvas.height);
  }

  if(cofre.blue.hp <= 0 || cofre.red.hp <= 0){
    running = false;
    platformOverlay.style.display = 'none';
    overlay.style.display = 'flex';
    overlay.querySelector('h2').innerText = cofre.blue.hp <= 0 ? 'Time Vermelho Venceu!' : 'Time Azul Venceu!';
  }
}

/* ----- Desenho (mantive o visual melhorado) ----- */
function radialGradient(ctx, x, y, r, colorCenter, colorEdge){
  const g = ctx.createRadialGradient(x, y, r*0.1, x, y, r);
  g.addColorStop(0, colorCenter);
  g.addColorStop(1, colorEdge);
  return g;
}
function drawBush(b){
  const x = b.x, y = b.y, s = b.s;
  const radius = 8;
  ctx.save();
  ctx.fillStyle = '#133b16';
  roundRect(ctx, x, y, s, s, radius);
  ctx.fill();
  const leafColors = ['#1f7d2a','#1b6b24','#2aa43b','#16611d'];
  const rows = 3;
  for(let ry=0; ry<rows; ry++){
    for(let cx2=0; cx2<3; cx2++){
      const lx = x + 8 + cx2 * (s-16)/2 + (ry%2 ? 6 : 0);
      const ly = y + 8 + ry * (s-10)/rows;
      const lw = 18 + (Math.random()*6 - 3);
      const lh = 10 + (Math.random()*4 - 2);
      ctx.beginPath();
      ctx.ellipse(lx, ly, lw, lh, Math.PI * (cx2%2 ? 0.15 : -0.12), 0, Math.PI*2);
      ctx.fillStyle = leafColors[(cx2+ry) % leafColors.length];
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lx - lw*0.5, ly);
      ctx.lineTo(lx + lw*0.5, ly);
      ctx.stroke();
    }
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.28)';
  ctx.lineWidth = 1;
  roundRect(ctx, x, y, s, s, radius);
  ctx.stroke();
  ctx.restore();
}
function drawWallBlock(w){
  ctx.save();
  const g = ctx.createLinearGradient(w.x, w.y, w.x + w.w, w.y + w.h);
  g.addColorStop(0, '#6a5a42');
  g.addColorStop(1, '#564532');
  ctx.fillStyle = g;
  ctx.fillRect(w.x, w.y, w.w, w.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.lineWidth = 1;
  const rows = Math.max(2, Math.floor(w.h / 16));
  for(let i=1;i<rows;i++){
    const yy = w.y + (w.h/rows)*i;
    ctx.beginPath();
    ctx.moveTo(w.x, yy); ctx.lineTo(w.x + w.w, yy); ctx.stroke();
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.12)';
  ctx.lineWidth = 1;
  const brickH = 18;
  for(let by = w.y; by < w.y + w.h; by += brickH){
    const isOdd = Math.floor((by - w.y) / brickH) % 2 === 1;
    const step = 40;
    for(let bx = w.x - (isOdd ? step/2 : 0); bx < w.x + w.w; bx += step){
      const x0 = Math.max(w.x, bx);
      const x1 = Math.min(w.x + w.w, bx + step);
      ctx.beginPath();
      ctx.moveTo(x0, Math.min(by + brickH, w.y + w.h));
      ctx.lineTo(x1, Math.min(by + brickH, w.y + w.h));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x1, by);
      ctx.lineTo(x1, Math.min(by + brickH, w.y + w.h));
      ctx.stroke();
    }
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 2;
  ctx.strokeRect(w.x, w.y, w.w, w.h);
  ctx.restore();
}
function drawCofre(c, colorHex){
  ctx.save();
  const px = c.x, py = c.y, pw = c.w, ph = c.h;
  const g = ctx.createLinearGradient(px, py, px, py + ph);
  g.addColorStop(0, shade(colorHex, 0.12));
  g.addColorStop(1, shade(colorHex, -0.08));
  ctx.fillStyle = g;
  roundRect(ctx, px, py, pw, ph, 6);
  ctx.fill();
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  roundRect(ctx, px + pw*0.08, py + ph*0.12, pw*0.84, ph*0.76, 4);
  ctx.fill();
  const lidH = ph * 0.28;
  const lg = ctx.createLinearGradient(px, py, px, py + lidH);
  lg.addColorStop(0, '#ffffff20');
  lg.addColorStop(1, '#00000010');
  ctx.fillStyle = lg;
  roundRect(ctx, px, py, pw, lidH, 6);
  ctx.fill();
  const lockX = px + pw/2;
  const lockY = py + ph/2 + 4;
  ctx.fillStyle = '#bfa86a';
  ctx.beginPath();
  ctx.ellipse(lockX, lockY, 10, 12, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#7a5f3a';
  ctx.fillRect(lockX - 4, lockY - 2, 8, 4);
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  const rivets = [
    [px + 8, py + 8],[px + pw - 8, py + 8],
    [px + 8, py + ph - 8],[px + pw - 8, py + ph - 8]
  ];
  for(const r of rivets){
    ctx.beginPath();
    ctx.arc(r[0], r[1], 3, 0, Math.PI*2);
    ctx.fill();
  }
  const barW = 180;
  const bx = px + pw/2 - barW/2;
  const by = py - 18;
  ctx.fillStyle = 'rgba(0,0,0,0.66)'; ctx.fillRect(bx,by,barW,10);
  const ratio = c.hp / c.maxHp;
  ctx.fillStyle = ratio>0.5 ? '#2b8' : (ratio>0.2 ? '#fa0' : '#f33');
  ctx.fillRect(bx+2, by+2, (barW-4) * clamp(ratio,0,1), 6);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(bx,by,barW,10);
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Cofre', px + pw/2, py + ph + 14);
  ctx.restore();
}
function drawBrawler(e){
  ctx.save();
  const alpha = inBush(e) ? 0.62 : 1.0;
  ctx.globalAlpha = alpha;
  const cx = e.x, cy = e.y, r = e.radius;
  let centerColor = e.team === 'blue' ? '#2f9cff' : '#ff5555';
  let edgeColor = shade(centerColor, -0.25);
  ctx.beginPath();
  ctx.fillStyle = radialGradient(ctx, cx - r*0.3, cy - r*0.4, r, centerColor, edgeColor);
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.ellipse(cx - r*0.25, cy - r*0.15, r*0.8, r*0.6, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(cx - 4, cy - 2, 2.6, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx + 4, cy - 2, 2.6, 0, Math.PI*2);
  ctx.fill();
  if(e.classType === 'tank'){
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.rect(cx - r*0.7, cy + r*0.2, r*1.4, 3);
    ctx.fill();
  } else if(e.classType === 'sniper'){
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath();
    ctx.rect(cx - r*0.2, cy - r*0.9, r*0.4, 6);
    ctx.fill();
  }
  const hpRatio = e.hp / e.maxHp;
  const bw = e.radius * 2.8;
  const bx = e.x - bw/2, by = e.y - e.radius - 12;
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(bx,by,bw,8);
  ctx.fillStyle = hpRatio>0.5 ? '#2b8' : (hpRatio>0.2 ? '#fa0' : '#f33');
  ctx.fillRect(bx+1, by+1, (bw-2) * clamp(hpRatio,0,1), 6);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(bx,by,bw,8);
  const ammoX = e.x - 12, ammoY = e.y + e.radius + 8;
  for(let a=0;a<e.ammoCapacity;a++){
    ctx.beginPath();
    ctx.fillStyle = a < e.ammo ? '#ffeb3b' : 'rgba(255,255,255,0.18)';
    ctx.arc(ammoX + a*11, ammoY, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();
  }
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}
function shade(hex, percent){
  const f = hex.slice(1);
  const r = parseInt(f.substring(0,2),16);
  const g = parseInt(f.substring(2,4),16);
  const b = parseInt(f.substring(4,6),16);
  const t = percent < 0 ? 0 : 255;
  const p = Math.abs(percent);
  const nr = Math.round((t - r)*p) + r;
  const ng = Math.round((t - g)*p) + g;
  const nb = Math.round((t - b)*p) + b;
  return `rgb(${nr},${ng},${nb})`;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  ctx.fillStyle = '#5a9';
  ctx.fillRect(0,0,WORLD.w,WORLD.h);
  for(let i=0;i<60;i++){
    ctx.fillStyle = 'rgba(0,0,0,0.02)';
    ctx.fillRect(30 + i*24, 30 + (i%7)*40, 2, 2);
  }
  for(const b of bushes) drawBush(b);
  for(const w of walls) drawWallBlock(w);
  drawCofre(cofre.blue, '#2f9cff');
  drawCofre(cofre.red, '#ff5555');

  for(const p of bullets){
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,238,120,0.98)';
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.arc(p.x - p.vx*0.12, p.y - p.vy*0.12, p.r*0.8, 0, Math.PI*2);
    ctx.fill();
  }

  for(const e of entities) if(e.alive) drawBrawler(e);

  for(const e of entities){
    if(e.alive) continue;
    if(e.respawnAt){
      const left = Math.max(0, Math.ceil(e.respawnAt - performance.now()/1000));
      ctx.beginPath();
      ctx.fillStyle = e.team === 'blue' ? '#2f9cff' : '#ff5555';
      ctx.arc(e.spawnX, e.spawnY, 10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(left, e.spawnX, e.spawnY);
    }
  }

  ctx.restore();

  // crosshair (desktop): desenha uma mira na posição do mouse (coordenadas de tela)
  if(!isMobile && running && typeof mouse.x === 'number'){
    const sx = mouse.x - camera.x;
    const sy = mouse.y - camera.y;
    ctx.save();
    // círculo externo sutil
    ctx.beginPath();
    ctx.arc(sx, sy, 10, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // linhas da mira
    ctx.beginPath();
    ctx.moveTo(sx - 14, sy);
    ctx.lineTo(sx - 6, sy);
    ctx.moveTo(sx + 6, sy);
    ctx.lineTo(sx + 14, sy);
    ctx.moveTo(sx, sy - 14);
    ctx.lineTo(sx, sy - 6);
    ctx.moveTo(sx, sy + 6);
    ctx.lineTo(sx, sy + 14);
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  topUI.innerHTML = `<span class="cofre-dot cofre-blue"></span> Cofre Azul: ${Math.max(0, Math.round(cofre.blue.hp))} &nbsp;&nbsp; — &nbsp;&nbsp; <span class="cofre-dot cofre-red"></span> Cofre Vermelho: ${Math.max(0, Math.round(cofre.red.hp))}`;
}

/* ----- Loop principal ----- */
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

/* ----- Iniciar/Resetar jogo ----- */
function clearState(){
  entities = []; bullets = []; bushes = []; walls = [];
  player = null;
  cofre.blue.hp = cofre.blue.maxHp;
  cofre.red.hp = cofre.red.maxHp;
}

function spawnTeams(chosenClass){
  const blueSpawnX = cofre.blue.x + cofre.blue.w + 40, blueSpawnY = cofre.blue.y + cofre.blue.h/2;
  const redSpawnX = cofre.red.x - 40, redSpawnY = cofre.red.y + cofre.red.h/2;
  spawn('blue', blueSpawnX, blueSpawnY-60, chosenClass, true);
  spawn('blue', blueSpawnX, blueSpawnY + 20, 'shotgun');
  spawn('blue', blueSpawnX, blueSpawnY + 100, 'tank');
  spawn('red', redSpawnX, redSpawnY-100, 'sniper');
  spawn('red', redSpawnX, redSpawnY + 20, 'shotgun');
  spawn('red', redSpawnX, redSpawnY + 100, 'tank');
}

function startGame(chosenClass){
  currentClass = chosenClass || currentClass;
  platformOverlay.style.display = 'none';
  overlay.style.display = 'none';
  clearState();
  createMap();
  spawnTeams(currentClass);
  cofre.blue.hp = cofre.blue.maxHp = 5000;
  cofre.red.hp = cofre.red.maxHp = 5000;
  running = true;
  lastTime = performance.now();
  if(!loopStarted){ loopStarted = true; gameLoop(); }
}

/* Restart */
function restartGame(){
  running = false;
  setTimeout(()=>{
    startGame(currentClass);
  }, 60);
}
restartBtn.addEventListener('click', restartGame);

/* Menu: volta para escolha de plataforma (assim o jogador pode trocar) */
menuBtn.addEventListener('click', ()=>{
  running = false;
  platformOverlay.style.display = 'flex';
  overlay.style.display = 'none';
});

/* Platform choice clicks */
chooseDesktop.addEventListener('click', ()=>{
  isMobile = false;
  platformOverlay.style.display = 'none';
  overlay.style.display = 'flex';
});
chooseMobile.addEventListener('click', ()=>{
  isMobile = true;
  platformOverlay.style.display = 'none';
  overlay.style.display = 'flex';
});

/* Inicial */
createMap();
platformOverlay.style.display = 'flex';

</script>
</body>
</html>

